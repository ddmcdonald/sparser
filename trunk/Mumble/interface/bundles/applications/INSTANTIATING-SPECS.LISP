;;; -*- Mode: Lisp; Package:MUMBLE; Syntax: COMMON-LISP; Base:10; -*-;;;;;;  MUMBLE-86:  interface>applications> instantiating-specifications;;;;;; Copyright (C) 1985, 1986, 1987, 1988, 1995  David D. McDonald and the;;;    Mumble Development Group.  All rights reserved.;;;    Permission is granted to use and copy this file of the Mumble-86 system for;;;    non-commercial purposes.;; ChangeLog:;;   5/31/95 ddm -- Added global to point to the object being instantiated(in-package "MUMBLE")(defvar *object-being-instantiated* nil)(defun INSTANTIATE-MAPPING (object)  "Looks up and executes a pre-established link between the Object and    one of various means of constructing a realization specification   for it.  Returns the specification. "  (let ((*object-being-instantiated* object))    (if (named-objectp object) ;; already mapped       ;; named object means it's a      object                 ;; mumble-object      (let ((realization-specification             (or (let ((table-entry (default-specification object)))		   ;(format t "~% object: ~s; def-spec: ~s ~%" object table-entry)                   (if table-entry                     (instantiate-table-entry table-entry object)))                 (let ((class-table-entry                        (walk-up-class-hierarchy                         'default-specification                         object)))                   (when class-table-entry                     (instantiate-class-table-entry                      class-table-entry                      object)))                 (unless (null application-specific-mapping-algorithm)                   (computed-mapping object))                 )))	(unless realization-specification	  (mbug "No known way to map ~a to a realization specification" object))	realization-specification))))(defun WALK-UP-CLASS-HIERARCHY (table-access-function					object)  (do* ((class (member-of-a-class? object)	       (member-of-a-class? class))	(table-entry	  (funcall table-access-function class)	  (funcall table-access-function class)))             ((or (null class)	    (eq class 'symbol)	    table-entry)	table-entry)    ))(defun COMPUTED-MAPPING (object)  (let ((result-of-mapping	  (funcall application-specific-mapping-algorithm object)))    (etypecase result-of-mapping      (cons	(let ((template  (car result-of-mapping))	      (arguments (cdr result-of-mapping)))	  (when (not (specification-templatep template))	    (mbug "The computed mapping for ~A yielded ~A, which ~                   is not an object of type specification-template"		  object template))	  (if (consp arguments)	      	      (apply-template template arguments)	      (funcall-template template arguments))))      (specification	result-of-mapping))))(defvar APPLICATION-SPECIFIC-MAPPING-ALGORITHM  nil  "Set to the name of the appropriate function by an application.")(defun INSTANTIATE-TABLE-ENTRY (table-entry object)    (let-with-dynamic-extent ((self object))    (let ((rspec	    (apply (function-from-objects-to-rspecs		     (template table-entry))		   (arguments-to-the-template table-entry))))      (link-to-underlying-object rspec object)      rspec)))(defun INSTANTIATE-CLASS-TABLE-ENTRY (table-entry object)  (let-with-dynamic-extent ((self object))    (let ((rspec	    (apply (function-from-objects-to-rspecs (template table-entry))		   (mapcar #'eval			   (arguments-to-the-template table-entry)))))    (link-to-underlying-object rspec object)    rspec)))	  (defun APPLY-TEMPLATE (template-name argument-list)  (let ((template (if (specification-templatep template-name)		      template-name		      (specification-template-named template-name))))    (when (null template)      (mbug "No specification-template named ~A" template-name))    (apply (symbol-function (function-from-objects-to-rspecs template))	   argument-list)))(defun FUNCALL-TEMPLATE (template-name &rest argument-list)  (apply-template template-name argument-list))