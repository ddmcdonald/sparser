;;; -*- Mode: Lisp; Syntax: Common-lisp; Package: Sparser; -*-;;; copyright (c) 2000 David D. McDonald, all rights reserved;;;;;;     file: "map translations";;;   module: "ts-readers;drivers:";;;  version: August 2000;; created 6/28/00. Debugged for unforseen case 8/1.(in-package :sparser)#| Right now (6/00) the mapping tables in the realization data of categoriesare formulated to the benefit of creating grammar rules, which means that theyare given in terms of categories. To invert them for generation we need torework them to use variables instead because that is what we'll need to getto bindings. Done right, this would have happened at definition time and we'dhave a richer structure than we presently do. I'm in a hurry to get someprincipled output, hence this kludge. |#(defparameter *variable-mapping-cache* (make-hash-table))(defun Reformulate-realization-map (category original-map)  ;; called from Map-schema-argument-to-value-in-unit  (or (gethash original-map *variable-mapping-cache*)      (let ((variables (cat-slots category))            etf-symbol  term  variable  new-map )        (dolist (entry original-map)          (setq etf-symbol (car entry)                term (cdr entry))          (setq variable                (find-corresponding-variable term variables))          (unless variable            (break "No variable in ~a~                    ~%corresponding to ~a" category term))          (push `(,etf-symbol . ,variable)                new-map))        (setq new-map (nreverse new-map))        (setf (gethash original-map *variable-mapping-cache*) new-map)        new-map)))(defun Find-corresponding-variable (unit variables)  (or (and (typep unit 'lambda-variable)           unit)      (let* ((pname               (etypecase unit                (referential-category (symbol-name (cat-symbol unit)))))             (category              (etypecase unit                (referential-category unit)))             (category-name              (etypecase unit                (referential-category                 (symbol-name (cat-symbol category)))))             (variable              (if (eq pname category-name)                category                (find pname variables :key #'var-name :test #'eq))))        ;(break)        variable)))                             (defun Value-of-mapping-term (variable unit)  (if (referential-category-p variable) ;; self node    variable    ;; Otherwise get the value out of the binding.    (let ((value           (etypecase unit             (psi              (let ((v+v                     (find variable (psi-v+v unit)                            :key #'vv-variable :test #'eq)))                (when v+v                  (vv-value v+v)))))))      value )))